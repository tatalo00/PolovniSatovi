// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL") // runtime / PgBouncer
  directUrl = env("DIRECT_URL") // migrations
}

// Core models for MVP

model User {
  id                   String    @id @default(cuid())
  email                String    @unique
  emailVerified        DateTime?
  name                 String?
  image                String?
  password             String? // For email/password auth
  passwordResetToken   String?
  passwordResetExpires DateTime?
  role                 UserRole  @default(BUYER)
  locale               String?   @db.VarChar(8)
  phoneVerified        Boolean   @default(false)
  isVerified           Boolean   @default(false)
  locationCountry      String?
  locationCity         String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  accounts            Account[]
  sessions            Session[]
  sellerProfile       SellerProfile?
  listings            Listing[]
  messages            Message[]
  threadsBuyer        MessageThread[]      @relation("buyerThreads")
  threadsSeller       MessageThread[]      @relation("sellerThreads")
  favorites           Favorite[]
  reports             Report[]             @relation("userReports")
  reviews             Review[]             @relation("reviews")
  sellerReviews       Review[]             @relation("sellerReviews")
  listingStatusAudits ListingStatusAudit[]
  authentication      UserAuthentication?
  sellerApplication   SellerApplication?
}

enum UserRole {
  BUYER
  SELLER
  ADMIN
}

model SellerProfile {
  id               String   @id @default(cuid())
  userId           String   @unique
  user             User     @relation(fields: [userId], references: [id])
  storeName        String
  slug             String?  @unique
  description      String?
  shortDescription String?  @db.VarChar(320)
  locationCountry  String
  locationCity     String
  logoUrl          String?
  heroImageUrl     String?
  ratingAvg        Decimal? @db.Decimal(3, 2)
}

enum SellerApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SellerType {
  OFFICIAL
  INDEPENDENT
}

model SellerApplication {
  id               String                  @id @default(cuid())
  userId           String                  @unique
  user             User                    @relation(fields: [userId], references: [id])
  sellerType       SellerType
  storeName        String
  shortDescription String
  locationCountry  String
  locationCity     String
  instagramHandle  String?
  proofUrl         String?
  status           SellerApplicationStatus @default(PENDING)
  notes            String?
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
}

model Listing {
  id               String        @id @default(cuid())
  sellerId         String
  seller           User          @relation(fields: [sellerId], references: [id])
  title            String // Kept for backward compatibility, will be computed from brand+model
  brand            String
  model            String
  reference        String?
  year             Int?
  condition        String
  gender           Gender        @default(UNISEX)
  priceEurCents    Int
  currency         String        @default("EUR")
  boxPapers        String?
  description      String?
  caseDiameterMm   Int?
  caseThicknessMm  Int?
  caseMaterial     String?
  waterResistanceM Int?
  movement         String?
  movementType     String?
  caliber          String?
  dialColor        String?
  dateDisplay      String?
  bezelType        String?
  bezelMaterial    String?
  strapType        String?
  braceletMaterial String?
  strapWidthMm     Int?
  warranty         String?
  warrantyCard     Boolean?
  originalOwner    Boolean?
  runningCondition String?
  location         String?
  status           ListingStatus @default(DRAFT)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  photos       ListingPhoto[]
  threads      MessageThread[]
  favorites    Favorite[]
  reports      Report[]
  reviews      Review[]
  statusAudits ListingStatusAudit[]

  @@index([brand])
  @@index([model])
  @@index([title])
  @@index([status])
  @@index([priceEurCents])
  @@index([createdAt])
  // Composite indexes for common query patterns
  @@index([status, priceEurCents])
  @@index([status, createdAt])
  @@index([status, brand])
  @@index([status, priceEurCents, createdAt])
  // Additional composite indexes for filter combinations
  @@index([status, movement])
  @@index([status, condition])
  @@index([status, year])
  @@index([status, sellerId])
  @@index([sellerId, status])
}

enum Gender {
  MALE
  FEMALE
  UNISEX
}

enum ListingStatus {
  DRAFT
  PENDING
  APPROVED
  REJECTED
  ARCHIVED
  SOLD
}

model ListingStatusAudit {
  id        String        @id @default(cuid())
  listingId String
  listing   Listing       @relation(fields: [listingId], references: [id])
  userId    String
  user      User          @relation(fields: [userId], references: [id])
  status    ListingStatus
  createdAt DateTime      @default(now())

  @@index([listingId])
  @@index([userId])
}

model ListingPhoto {
  id        String  @id @default(cuid())
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id])
  url       String
  order     Int     @default(0)

  @@index([listingId])
}

model MessageThread {
  id        String   @id @default(cuid())
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id])
  buyerId   String
  sellerId  String
  buyer     User     @relation("buyerThreads", fields: [buyerId], references: [id])
  seller    User     @relation("sellerThreads", fields: [sellerId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages Message[]
}

model Message {
  id        String        @id @default(cuid())
  threadId  String
  thread    MessageThread @relation(fields: [threadId], references: [id])
  senderId  String
  sender    User          @relation(fields: [senderId], references: [id])
  body      String
  createdAt DateTime      @default(now())
  readAt    DateTime?

  @@index([threadId])
}

model Report {
  id         String       @id @default(cuid())
  listingId  String
  listing    Listing      @relation(fields: [listingId], references: [id])
  reporterId String
  reporter   User         @relation("userReports", fields: [reporterId], references: [id])
  reason     String
  status     ReportStatus @default(OPEN)
  createdAt  DateTime     @default(now())
}

enum ReportStatus {
  OPEN
  CLOSED
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id])
  createdAt DateTime @default(now())

  @@unique([userId, listingId])
}

model UserAuthentication {
  id                  String                   @id @default(cuid())
  userId              String                   @unique
  user                User                     @relation(fields: [userId], references: [id])
  status              UserAuthenticationStatus @default(PENDING)
  diditSessionId      String
  diditVerificationId String?
  diditSessionUrl     String?
  rejectionReason     String?
  statusDetail        String?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt

  @@index([status])
}

enum UserAuthenticationStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELED
}

model Review {
  id         String   @id @default(cuid())
  listingId  String?
  sellerId   String
  reviewerId String
  reviewer   User     @relation("reviews", fields: [reviewerId], references: [id], onDelete: Cascade)
  seller     User     @relation("sellerReviews", fields: [sellerId], references: [id], onDelete: Cascade)
  listing    Listing? @relation(fields: [listingId], references: [id], onDelete: Cascade)
  rating     Int // 1-5 stars
  title      String?
  comment    String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([reviewerId, listingId]) // One review per listing per user
  @@index([sellerId])
  @@index([listingId])
}

// Auth.js (NextAuth) required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
